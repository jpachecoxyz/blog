#+TITLE: jpacheco.xyz
#+AUTHOR: Javier Pacheco
#+DESCRIPTION: My website posts & projects.
#+hugo_base_dir: ~/webdev/github/test/
#+startup: content
#+hugo_auto_set_lastmod: t
#+date: 2024-07-04
#+seq_todo: TODO DOING DONE


* DONE About me.
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_DESCRIPTION: My personal information
:EXPORT_HUGO_SECTION: about
:END:

Greetings! I'm Javier Pacheco, a dedicated Industrial Maintenance Engineer with a rich academic foundation from the prestigious *UTM* in *H. Matamoros Tamaulipas,Mexico*. Over the span of 12 fruitful years, I've been an integral part of the automotive industry, contributing my expertise in a multitude of critical domains.

My journey began with a profound fascination for the intricate mechanisms that power manufacturing and industrial processes. At UTM, I honed my skills, diving deep into the realms of engineering, automation, and problem-solving. This foundation paved the way for my foray into the dynamic world of industrial maintenance.

Within the automotive landscape, I've carved my niche in handling Programmable Logic Controllers (PLCs), robotics, and programming, orchestrating seamless operations and bolstering efficiency. My prowess extends beyond conventional boundaries—I harness the power of CAD software to craft intricate designs that harmonize innovation with practicality.

Programming is not just a skill set; it's an intrinsic part of my identity. The allure of languages such as Python, C, and Lisp captivates me, compelling me to unravel their complexities and harness their capabilities to engineer groundbreaking solutions.

My career is a testament to my unwavering commitment to innovation and continuous learning. Each challenge fuels my passion, propelling me to explore new horizons and revolutionize conventional practices. I thrive in environments that demand ingenuity and embrace the convergence of technology and creativity.

Beyond the technical facets, I am deeply invested in collaborative endeavors, fostering a culture of knowledge exchange and mentorship. I firmly believe that sharing insights and empowering others amplifies the impact of technological advancements.

#+ATTR_HTML: :target _blank
See my whole information [[file:/documents/cv.pdf][here]].

** Where to Find Me
- [[https://github.com/engjpacheco][GitHub.]]
- [[https://www.linkedin.com/in/jpachecom4/][LinkedIn.]]

** Projects that I'm currently develop.
- [[https://github.com/engjpacheco/voidstrap][Void linux installation script.]]
- [[https://github.com/engjpacheco/noobemacs][Noobemacs, a minimal emacs configuration with evil mode.]]
- [[https://github.com/engjpacheco/pymetrics][pymetrics, a python gui app to manage maintenance logs.]]
  
* DONE Screen Record                          :shell:script:hyprland:wayland:
CLOSED: [2024-03-15 Fri 04:14]
:PROPERTIES:
:EXPORT_FILE_NAME: screen-record
:EXPORT_DESCRIPTION: Script to record in hyprland
:EXPORT_HUGO_SECTION: posts
:END:

This script record the screen with the =wf-recorder= tool, it can be the hole screen or a specific area of it.
The script is going to store the video in =/tmp/screencast.mp4=, this script only store one video, personally I think that have more than one record is a mess, more if you only wants to share a quick screencast to /telegram, irc, cinny/ or even to share it through =0x0.st=.

** Description and main variables:
#+begin_src shell
# Created By: Javier Pacheco - javier@jpacheco.xyz
# Created On: 29/03/24
# Project: Screen recorder in wayland
# Dependencies: wf-recorder wl-copy and a launcher like dmenu, fuzzel, etc.

SOUND_CARD=$(pactl list sources | awk '/Name/ && /.monitor/ {print $2}')
#+end_src

** Recording functions:
Those functions have enable the sound recording, so if you have some music, video, etc running it will record the sound but not the mic.

*** screencast:
This option is going to record a specific area of the screen.
This area is going to be specified by =slurp=.
#+begin_src shell
screencast() {
   wf-recorder --audio=$SOUND_CARD -f /tmp/screencast.mp4
}
#+end_src

*** area:
This option is going to record a specific area of the screen.
This area is going to be specified by =slurp=.
#+begin_src shell
area() {
   wf-recorder --audio=$SOUND_CARD -g "$(slurp)" -f /tmp/screencast.mp4
}
#+end_src

** Useful functions:
These functions are tools that ensures this script works correctly. For example if all ready have a existing file recorded, it will removed to record a new one, because this script only will create one video always, and also have a function to kill the process when it finished. 

*** check internet connection:
#+begin_src shell
check_connection() {
    ping -c 1 google.com 1> /dev/null 2>&1
}
#+end_src

*** share:
This option is going to upload the video to =0x0.st= and copy the url to the clipboard using =wc-copy=.
#+begin_src shell
share() {
   notify-send "uploading.." "video is upoading to 0x0.st"
   curl -F "file=@/tmp/screencast.mp4" https://0x0.st | wl-copy && notify-send "Video stored in 0x0.st"
}
#+end_src

*** Kill existing process:
#+begin_src shell
kill_proc(){
    pkill --signal SIGINT wf-recorder
    if [ $? -eq 0 ];
    then
        notify-send "Video stored" "Video was stored in /tmp/screencast.mp4"
        pkill --signal SIGINT wf-recorder
        exit 0
    fi
}
#+end_src

*** Remove existing video:
#+begin_src shell
remove_vid() {
    [ -f /tmp/screencast.mp4 ] && rm /tmp/screencast.mp4
}
#+end_src

** Sequence:
This is were the scripts actually starts, first of all look if the script is already running, if not then ask for a recording option: 
#+begin_src shell
kill_proc

OPT=$(printf "screencast\narea\nshare\nquit" | fuzzel --dmenu -p 'Select an option: ' )
case $OPT in
    'screencast')
        sleep 1
        remove_vid
        sleep 1
        screencast;;
    'area')
        sleep 1
        remove_vid
        sleep 1
        area;;
    'share') 
        check_connection && share || notify-send "Error" "check your internet connection" ;;
    *|quit) exit 0;;
esac
#+end_src

* DONE Efetch.el                                                :emacs:fetch:
CLOSED: [2024-01-13 Sat 04:11]
:PROPERTIES:
:EXPORT_FILE_NAME: efetch
:EXPORT_DESCRIPTION: A emacs fetching tool.
:CREATED:     2023-07-05
:EXPORT_HUGO_SECTION: posts
:END:

#+BEGIN_PREVIEW
Embrace a new level of Emacs mastery with =efetch.el= – a powerful and user-friendly Emacs Fetching Tool. Designed for enthusiasts who crave insights into their Emacs environment, =efetch.el= provides a seamless way to peek under the hood of your setup. With just a simple command, unlock a left-side buffer showcasing key details such as Emacs version, host information, user details, installed packages, active theme, and default font. Customizable and accessible, this tool not only delivers a quick snapshot of your Emacs configuration but also opens the door for collaborative enhancements. Join the community on [GitHub](https://github.com/engjpacheco/efetch.el), contribute your ideas, and elevate your Emacs experience with =efetch.el= today!
#+END_PREVIEW

#+begin_center
#+CAPTION: efetch.el tool in the left side of the frame.
[[/images/content/efetch.png]]
#+end_center

** Overview
Are you an Emacs enthusiast who loves to keep track of your environment details? Look no further! We are excited to introduce =efetch.el= - the Emacs Fetching Tool. This nifty extension provides a quick and informative snapshot of your Emacs setup, helping you stay in the know about your environment configuration.

** Features
- **Quick Access**: Invoke =efetch= with a simple command to access a left-side buffer displaying essential information about your Emacs environment.

- **Information at a Glance**: Get a concise overview, including Emacs version, host details, user information, installed packages, active theme, and default font.

- **Customization**: Tailor the appearance and information displayed in the =efetch= buffer to suit your preferences.

- **Convenient Keyboard Shortcut**: Close the =efetch= buffer and its window effortlessly with the =q= key.

** How to Use
1. **Installation**: Add the following line to your Emacs configuration:

 #+BEGIN_SRC emacs-lisp
(require 'efetch)
 #+END_SRC

Ensure the =efetch.el= file is in a directory included in your =load-path=.

2. **Usage**: Invoke =efetch= interactively using:

#+begin_example
M-x efetch
#+end_example

The information will be displayed in a left-side buffer named *efetch-popup*.

** Customization
Feel free to customize the appearance or the information displayed in the =efetch= buffer by modifying the relevant sections in the =efetch= function.

** Contribution
We welcome contributions and feedback! =efetch.el= is hosted on [[https://github.com/engjpacheco/efetch.el][github]]. Feel free to [[https://github.com/engjpacheco/efetch.el/fork][fork the repository]] and submit pull requests. 
The project is open to changes, improvements, and collaborations.

** Get Started

Enhance your Emacs experience with =efetch.el=! Stay informed about your environment effortlessly. Download and integrate it into your Emacs setup today.

* DONE Void linux bootstrap.                           :void:installer:linux:
:PROPERTIES:
:EXPORT_FILE_NAME: voidstrap
:EXPORT_DESCRIPTION: A void linux semi-automated installer.
:DATE:     07-05-2024
:EXPORT_HUGO_SECTION: projects
:END:

#+BEGIN_PREVIEW
This is the first post of the 2024, this is a project that I am working on in the last
year, is a minimialist voidlinux instalator it is based in some recomendations in 
a guides that some friends of my have but "semiautomated".
#+END_PREVIEW

** VoidStrap installer.
A basic minimalist installer of =void-linux= with some packages to get ready to enjoy
this amazing GNU/Linux distribution.

** Usage:

*** Running install.sh

Download the iso, and once in root inside the live, git clone this repo:
(You need to update inside the iso and install =git=)

NOTE: there are 3 =branches:=
- main :: This will install =void-musl=.
- glibc :: This will install =void-glibc=.
- dual :: This will install =void-glibc= dual boot with =Windows=.
  - *This branch is tested only with =Windows=, I never try it with other distributions.*
  - If you want musl you can change the link to the mirror in the =install.sh= script:
#+begin_example
- Change this in line 11:
export XBPS_ARCH=x86_64 && xbps-install -Suy -R http://mirrors.servercentral.com/voidlinux/current -r /mnt \
- For this:
export XBPS_ARCH=x86_64-musl && xbps-install -Suy -R http://mirrors.servercentral.com/voidlinux/current/musl -r /mnt \
#+end_example
    
#+begin_src shell
git clone https://git.disroot.org/jpacheco/voidstrap
cd voidstrap
sh install.sh
#+end_src

Once there the script will open =cfdisk=, and you need to format the HDD in this 
specific format:
#+begin_example
- /dev/sdX1 -> as the boot partition.
- /dev/sdY2 -> as the swap partition.
- /dev/sdZ3 -> as the root partition.
#+end_example

NOTE: Replace X,Y & Z for your partition name.
I consider to have this structure of partition, but you can change it, but you must
change the code in =postinstall.sh= when the scripts make the =fstab= archive.

*Make sure you do a backup of your files before doing crazy things and trust anyone script*

When the =install.sh= script finish, you need to run the postinstall script located in =/root folder:=

*** Running postinstall.sh

This script its going to create some configuration files, like: =fstab=, =rc.conf=,
change the password of =root=, and add user(s).

#+begin_src shell
xchroot /mnt
#+end_src

Then run the =chroot.sh= script.
#+begin_src shell
sh /root/postinstall.sh
#+end_src

When the =postinsall.sh= script finishes, you only need to reboot and enjoy your
*Void-Linux* distribution.

When it finish you need to run the =postinstall.sh= script, that is going to install
the *X server* and some other "necessary" packages.


** The custom.sh script

This is going to install my personal dotfiles, and a specific packages that I use:
#+begin_src shell
sh /root/custom.sh
#+end_src

But you can specify your dotfiles repositories and others that you require whit some parameters:

#+begin_src 
sh custom.sh -r https://codeberg.org/jpacheco/dotfiles # specify a repo url.
sh custom.sh -p otherprogfile.csv # especify a custom package archive to install.
sh custom.sh -b dev # especify the name of a custom branch in case of needed.
#+end_src

** References:
- [[https://codeberg.org/jpacheco/voidstrap][Voidstrap.]]
- [[https://docs.voidlinux.org/][Voidlinux Documentation.]] 
- [[https://git.disroot.org/tuxliban/tutoriales_void/src/branch/master/Gu%C3%ADas][Tuxliban guides.]]
